{"version":3,"sources":["hooks/useArray.tsx","hooks/useAlphabet.tsx","hooks/useLog.tsx","hooks/useGame.tsx","components/Node.tsx","components/Guesses.tsx","components/Keyboard.tsx","components/InputWord.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["useArray","initial","useState","data","setData","push","element","remove","index","filter","_","i","update","length","previousData","slice","isEmpty","reset","initializeAlphabet","alphabet","start","charCodeAt","String","fromCharCode","useLog","name","useEffect","console","log","initHistory","history","j","ch","color","randomInt","end","Math","floor","random","useGame","row","setRow","wordle","setWordle","setAlphabet","status","prevState","updateNever","undefined","updateAlmost","updateSuccess","useAlphabet","setStatus","answers","useRef","words","Set","parseTextFile","filename","fetch","process","then","res","text","split","fetchWords","a","answersArr","wordsArr","current","concat","getCharColors","guess","wordColors","wordleSet","has","newGame","submitGuess","word","statusColor","init","success","almost","never","areEqual","prevProps","nextProps","pair","Node","style","React","memo","Guesses","guesses","map","rows","Keyboard","characters","toUpperCase","handleSubmit","input","setInput","onSubmit","e","onChange","target","value","App","onClick","InputWord","preventDefault","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"gNAGaA,EAAW,SAAXA,IAAkD,IAAvBC,EAAsB,uDAAP,GACrD,EAAwBC,mBAASD,GAAjC,mBAAOE,EAAP,KAAaC,EAAb,KAGMC,EAAO,SAACC,GACZF,EAAQ,GAAD,mBAAKD,GAAL,CAAWG,MAIdC,EAAS,SAACC,GACdJ,EAAQD,EAAKM,QAAO,SAACC,EAAGC,GAAJ,OAAUA,IAAMH,OAIhCI,EAAS,SAACJ,EAAeF,GAC1BE,EAAQ,GAAKA,GAASL,EAAKU,QAE9BT,GAAQ,SAACU,GAAD,4BACFA,EAAaC,MAAM,EAAGP,IADpB,CAC4BF,GAD5B,YACwCQ,EAAaC,MAAMP,EAAM,EAAGM,EAAaD,cAIrFG,EAAU,kBAA+B,IAAhBb,EAAKU,QAE9BI,EAAQ,kBAAYb,EAAQ,KAElC,MAAO,CAAED,OAAMC,UAASJ,WAAUK,OAAME,SAAQK,SAAQK,QAAOD,Y,cCvB3DE,EAAqB,WAGzB,IAFA,IAAIC,EAAqB,GACnBC,EAAQ,IAAIC,WAAW,GACrBV,EAAIS,EAAOT,EAAIS,EAAQ,GAAIT,IACjCQ,EAASG,OAAOC,aAAaZ,IAAM,OAErC,OAAOQ,GCVIK,EAAS,SAAgBC,EAActB,GAClDuB,qBAAU,WACRC,QAAQC,IAAIH,EAAMtB,KACjB,CAACsB,EAAMtB,KCEN0B,EAAc,WAElB,IADA,IAAIC,EAAyB,GACrBnB,EAAI,EAAGA,EAJG,EAIcA,IAAM,CACpCmB,EAAQzB,KAAK,IACb,IAAI,IAAI0B,EAAI,EAAGA,EALA,EAKgBA,IAC7BD,EAAQnB,GAAGN,KAAM,CAAC2B,GAAI,IAAKC,MAAO,UAGtC,OAAOH,GAIHI,EAAY,SAACd,EAAee,GAChC,OAAOf,EAAQgB,KAAKC,MAAMD,KAAKE,UAAYH,EAAMf,EAAQ,KAS9CmB,EAAU,WACrBZ,QAAQC,IAAI,kBACZ,MAAsB1B,mBAAiB,GAAvC,mBAAOsC,EAAP,KAAYC,EAAZ,KACA,EAA4BvC,mBAAiB,IAA7C,mBAAOwC,EAAP,KAAeC,EAAf,KACMxB,EFlBmB,WACzB,MAAgCjB,mBAAmBgB,KAAnD,mBAAOC,EAAP,KAAiByB,EAAjB,KAGMhC,EAAS,SAACoB,EAAYa,GACvB1B,EAASa,KAAQa,GAEpBD,GAAY,SAACE,GAAD,mBAAC,eAA6BA,GAA9B,kBAA0Cd,EAAKa,QA4B7D,MAAO,CAAE1B,WAAU4B,YAxBC,SAACf,QACGgB,KAAX,OAAR7B,QAAQ,IAARA,OAAA,EAAAA,EAAWa,KAAwC,WAAX,OAARb,QAAQ,IAARA,OAAA,EAAAA,EAAWa,KAAsC,YAAX,OAARb,QAAQ,IAARA,OAAA,EAAAA,EAAWa,KAAuC,aAAX,OAARb,QAAQ,IAARA,OAAA,EAAAA,EAAWa,KAC3GpB,EAAOoB,EAAI,UAsBmBiB,aAlBX,SAACjB,QACEgB,KAAX,OAAR7B,QAAQ,IAARA,OAAA,EAAAA,EAAWa,KAAwC,YAAX,OAARb,QAAQ,IAARA,OAAA,EAAAA,EAAWa,KAAuC,aAAX,OAARb,QAAQ,IAARA,OAAA,EAAAA,EAAWa,KAC7EpB,EAAOoB,EAAI,WAgBiCkB,cAXxB,SAAClB,QACCgB,KAAX,OAAR7B,QAAQ,IAARA,OAAA,EAAAA,EAAWa,KAAwC,aAAX,OAARb,QAAQ,IAARA,OAAA,EAAAA,EAAWa,KAC9CpB,EAAOoB,EAAI,YASgDf,MAJ/C,WACZ2B,EAAY1B,OEdGiC,GACXrB,EAAU9B,EAAsB6B,KACtC,EAA4B3B,mBAAiB,WAA7C,mBAAO2C,EAAP,KAAeO,EAAf,KACMC,EAAUC,iBAAiB,IAC3BC,EAAQD,iBAAoB,IAAIE,KAEtChC,EAAO,YAAaM,EAAQ3B,MAC5BqB,EAAO,aAAcL,EAASA,UAE9BO,qBAAU,WAER,IAAM+B,EAAgB,SAACC,GACrB,OAAOC,MAAM,GAAD,OAAIC,qBAAJ,YAA8BF,IACzCG,MAAK,SAACC,GAAD,OAASA,EAAIC,UAClBF,MAAK,SAACE,GACL,OAAOA,EAAKC,MAAM,aAKhBC,EAAU,uCAAG,8BAAAC,EAAA,sEACQT,EAAc,eADtB,cACXU,EADW,gBAEMV,EAAc,aAFpB,OAEXW,EAFW,OAGjBf,EAAQgB,QAAUF,EAClBZ,EAAMc,QAAU,IAAIb,IAAIY,EAASE,OAAOH,IAJvB,2CAAH,qDAQhBF,IACCJ,MAAK,WACJ,IAAMrD,EAAQ0B,EAAU,EAAGmB,EAAQgB,QAAQxD,QAC3C8B,EAAUU,EAAQgB,QAAQ7D,SAE3B,IAEH,IAuBM+D,EAAgB,SAACC,GAKrB,IAJA,IAAIC,EAA0B,GAC1BC,EAAY,IAAIlB,IAAId,GAGhB/B,EAAI,EAAGA,EAAI6D,EAAM3D,OAAQF,IAAM,CACrC,IAAMqB,EAAawC,EAAM7D,GACtBqB,IAAOU,EAAO/B,IACf8D,EAAWpE,KAAM,CAAE2B,GAAIA,EAAIC,MAAO,YAClCd,EAAS+B,cAAclB,IAEjB0C,EAAUC,IAAI3C,IACpByC,EAAWpE,KAAM,CAAE2B,GAAIA,EAAIC,MAAO,WAClCd,EAAS8B,aAAajB,KAGtByC,EAAWpE,KAAM,CAAE2B,GAAIA,EAAIC,MAAO,UAClCd,EAAS4B,YAAYf,IAGzB,OAAOyC,GAGT,MAAO,CAAEjC,MAAKE,SAAQZ,UAASX,WAAU0B,SAAQ+B,QA9CjC,WACdjD,QAAQC,IAAI,oBACZ,IAAMpB,EAAQ0B,EAAU,EAAGmB,EAAQgB,QAAQxD,QAC3C8B,EAAUU,EAAQgB,QAAQ7D,IAC1BiC,EAAO,GACPX,EAAQ1B,QAAQyB,KAChBV,EAASF,QACTmC,EAAU,YAuC8CyB,YApCtC,SAACC,GACfvB,EAAMc,QAAQM,IAAIG,IAAoB,YAAXjC,IAE/Bf,EAAQlB,OAAO4B,EAAK+B,EAAcO,IAClCrC,EAAOD,EAAM,GACVsC,IAASpC,EACVU,EAAU,OACJZ,EAAI,IAhFI,GAiFdY,EAAU,Y,OCpFV2B,EAAsC,CAC1CC,KAAM,QACNC,QAAS,QACTC,OAAQ,SACRC,MAAO,QAYHC,EAAW,SAACC,EAAkBC,GAClC,OAAOD,EAAUE,KAAKvD,KAAOsD,EAAUC,KAAKvD,IAAMqD,EAAUE,KAAKtD,QAAUqD,EAAUC,KAAKtD,OAGtFuD,EAAO,SAAC,GAAqB,IAAnBD,EAAkB,EAAlBA,KACd,OAAO,sBAAME,MAAO,CAAExD,MAAO8C,EAAYQ,EAAKtD,QAAvC,SAAkDsD,EAAKvD,MAGjD0D,MAAMC,KAAKH,EAAMJ,GCd1BQ,EAAU,SAAC,GAAwB,IAAtBC,EAAqB,EAArBA,QAEjB,OADAlE,QAAQC,IAAI,kBAEV,mCACGiE,EAAQC,KAAI,SAACtB,EAAOhE,GAAR,OACX,iDACaA,EAAQ,EADrB,MAEGgE,EAAMsB,KAAI,SAACP,EAAM/E,GAAP,OACT,cAAC,EAAD,CAAiC+E,KAAMA,GAAvC,UAAcA,EAAKvD,IAAnB,OAAwBxB,SAHlBA,SAWHkF,MAAMC,KAAKC,GCzBpBG,EAAO,CACX,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAC9C,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KACzC,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,MAW3BC,EAAW,SAAC,GAAyB,IAAvB7E,EAAsB,EAAtBA,SAElB,OADAQ,QAAQC,IAAI,mBAEV,mCACGmE,EAAKD,KAAI,SAACG,EAAYzF,GAAb,OACR,8BACGyF,EAAWH,KAAI,SAAC9D,GAAD,OACd,cAAC,EAAD,CAEEuD,KAAM,CAAEvD,GAAIA,EAAGkE,cAAejE,MAAOd,EAASa,KADzCA,OAHDxB,SAaHkF,MAAMC,KAAKK,GC7BXN,MAAMC,MAAK,YAA8B,IAA3BQ,EAA0B,EAA1BA,aAC3B,EAA0BjG,mBAAiB,IAA3C,mBAAOkG,EAAP,KAAcC,EAAd,KACA,OACE,uBAAMC,SAAU,SAACC,GAAOJ,EAAaI,EAAGH,IAAxC,UACE,uBAAOI,SAAU,SAACD,GAAD,OAAOF,EAASE,EAAEE,OAAOC,QAAQA,MAAON,IACzD,mDCyBSO,EA9BH,WACVhF,QAAQC,IAAI,cACZ,MACEW,IADMC,EAAR,EAAQA,IAAKE,EAAb,EAAaA,OAAQZ,EAArB,EAAqBA,QAASX,EAA9B,EAA8BA,SAAU0B,EAAxC,EAAwCA,OAAQ+B,EAAhD,EAAgDA,QAASC,EAAzD,EAAyDA,YAQzD,OACE,gCACE,8BAAK,0DADP,kBAEchC,GACZ,uBAHF,mBAIeL,GACb,uBALF,kBAMcE,GACZ,uBACA,wBAAQkE,QAAShC,EAAjB,uBACA,uBACA,cAACiC,EAAD,CAAWV,aAhBM,SAACI,EAAoBH,GACxCG,EAAEO,iBACFjC,EAAYuB,MAeV,uBACA,cAAC,EAAD,CAASP,QAAS/D,EAAQ3B,OAC1B,uBACA,cAAC,EAAD,CAAUgB,SAAUA,EAASA,eCjBpB4F,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBpD,MAAK,YAAkD,IAA/CqD,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCHdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1BZ,M","file":"static/js/main.27b14621.chunk.js","sourcesContent":["import { useState } from 'react';\n\n// Purpose of this hook is to mimic normal arrays, this allows us to 'mutate' our state which we otherwise wouldn't be able to in React\nexport const useArray = <T extends any>(initial: T[] = []) => {\n  const [data, setData] = useState(initial)\n\n  // Can push to the data like normally when not using React\n  const push = (element: T): void => {\n    setData([...data, element])\n  };\n\n  // Can remove from index of the data like normally when not using React\n  const remove = (index: number): void => {\n    setData(data.filter((_, i) => i !== index))\n  };\n\n  // Update element at index with new element\n  const update = (index: number, element: T): void => {\n    if(index < 0 || index >= data.length)\n      return\n    setData((previousData) => \n      [...previousData.slice(0, index), element, ...previousData.slice(index+1, previousData.length)]\n    )\n  }\n\n  const isEmpty = (): boolean => data.length === 0;\n\n  const reset = (): void => setData([]);\n\n  return { data, setData, useArray, push, remove, update, reset, isEmpty } as const\n}","import { useState } from 'react';\n\ninterface Alphabet {\n  [key: string]: string\n}\n\nconst initializeAlphabet = (): Alphabet => {\n  let alphabet: Alphabet = {}\n  const start = 'a'.charCodeAt(0)\n  for(let i = start; i < start + 26; i ++) {\n    alphabet[String.fromCharCode(i)] = 'init'\n  }\n  return alphabet\n}\n\nexport const useAlphabet = () => {\n  const [alphabet, setAlphabet] = useState<Alphabet>(initializeAlphabet())\n\n  // Helper function to use 'setAlphabet' to prevent DRY\n  const update = (ch: string, status: string): void => {\n    if(alphabet[ch] === status)\n      return\n    setAlphabet((prevState: Alphabet) => ({...prevState, [ch]: status}))\n  }\n\n  // Updates a character to 'never'\n  const updateNever = (ch: string): void => {\n    if(alphabet?.[ch] === undefined || alphabet?.[ch] === 'never' || alphabet?.[ch] === 'almost' || alphabet?.[ch] === 'success') return\n    update(ch, 'never')\n  }\n\n  // Updates a character to 'almost'\n  const updateAlmost = (ch: string): void => {\n    if(alphabet?.[ch] === undefined || alphabet?.[ch] === 'almost' || alphabet?.[ch] === 'success') return\n    update(ch, 'almost')\n\n  }\n\n  // Updates a character to 'success'\n  const updateSuccess = (ch: string): void => {\n    if(alphabet?.[ch] === undefined || alphabet?.[ch] === 'success') return\n    update(ch, 'success')\n\n  }\n\n  // Reset alphabet to default\n  const reset = (): void => {\n    setAlphabet(initializeAlphabet())\n  }\n\n  return { alphabet, updateNever, updateAlmost, updateSuccess, reset } as const\n}","import { useEffect } from 'react';\n\nexport const useLog = <T extends any>(name: string, data: T) => {\n  useEffect(() => {\n    console.log(name, data)\n  }, [name, data])\n}","import { useState, useEffect, useRef } from 'react';\nimport { useArray } from './useArray';\nimport { useAlphabet } from './useAlphabet';\nimport { useLog } from './useLog';\n\nconst MAX_GUESSES = 6\nconst WORDLE_LEN = 5\nconst initHistory = (): CharColor[][] => {\n  let history: CharColor[][] = []\n  for(let i = 0; i < MAX_GUESSES; i ++) {\n    history.push([])\n    for(let j = 0; j < WORDLE_LEN; j ++) {\n      history[i].push( {ch: '_', color: 'never'} )\n    }\n  }\n  return history\n}\n\n// Returns random integer from [a, b]\nconst randomInt = (start: number, end: number): number => {\n  return start + Math.floor(Math.random() * (end - start + 1))\n}\n\n\ninterface CharColor {\n  ch: string\n  color: string\n}\n\nexport const useGame = () => {\n  console.log(\"render useGame\")\n  const [row, setRow] = useState<number>(0)\n  const [wordle, setWordle] = useState<string>('')\n  const alphabet = useAlphabet()\n  const history = useArray<CharColor[]>(initHistory())\n  const [status, setStatus] = useState<string>('ongoing')\n  const answers = useRef<string[]>([])\n  const words = useRef<Set<string>>(new Set())\n\n  useLog('history: ', history.data)\n  useLog('alphabet: ', alphabet.alphabet)\n\n  useEffect(() => {\n    // Function to read my text file from the 'public' folder\n    const parseTextFile = (filename: string): Promise<string[]> => {\n      return fetch(`${process.env.PUBLIC_URL}/${filename}`)\n      .then((res) => res.text())\n      .then((text) => {\n        return text.split(/\\r?\\n/)  // Split by /r/n on windows or /n on Unix using regex\n      })\n    }\n\n    // Parse 2 textfiles for possible answers + possible word guesses\n    const fetchWords = async (): Promise<void> => {\n      const answersArr = await parseTextFile('answers.txt')\n      const wordsArr = await parseTextFile('words.txt')\n      answers.current = answersArr\n      words.current = new Set(wordsArr.concat(answersArr))\n    }\n\n    // Pick a random wordle after fetching our words + answers\n    fetchWords()\n    .then(() => {\n      const index = randomInt(0, answers.current.length)\n      setWordle(answers.current[index])\n    })\n  }, [])\n  \n  const newGame = (): void => {\n    console.log(\"started new game\")\n    const index = randomInt(0, answers.current.length)  // Get a random index\n    setWordle(answers.current[index]) // Pick a random wordle\n    setRow(0) // Reset row\n    history.setData(initHistory()) // Reset history\n    alphabet.reset() // Reset alphabet\n    setStatus('ongoing')  // Reset status\n  }\n\n  const submitGuess = (word: string): void => {\n    if(!words.current.has(word) || status !== 'ongoing')\n      return\n    history.update(row, getCharColors(word))  // Update row { guesses } of our history with new guess\n    setRow(row + 1) // Increment guess count\n    if(word === wordle) // Check if game is over\n      setStatus('win')\n    else if(row+1 === MAX_GUESSES)\n      setStatus('lose')\n  }\n\n  // Input is the current guess\n  // Will update the alphabet with green/yellow/black colors and display the new word after\n  const getCharColors = (guess: string): CharColor[] => {\n    let wordColors: CharColor[] = []\n    let wordleSet = new Set(wordle)\n\n    // Iterate through each character of the guess word\n    for(let i = 0; i < guess.length; i ++) {\n      const ch: string = guess[i]\n      if(ch === wordle[i]) {  // Character at index i of guess is same as character of wordle\n        wordColors.push( { ch: ch, color: 'success' } )\n        alphabet.updateSuccess(ch)\n      }\n      else if(wordleSet.has(ch)) {  // Otherwise, check if guess char is a char in the wordle\n        wordColors.push( { ch: ch, color: 'almost' } )\n        alphabet.updateAlmost(ch)\n      }\n      else {  // Otherwise, mark the character as 'never' possible\n        wordColors.push( { ch: ch, color: 'never' } )\n        alphabet.updateNever(ch)\n      }\n    }\n    return wordColors\n  }\n\n  return { row, wordle, history, alphabet, status, newGame, submitGuess } as const\n}","import React from \"react\";\n\nconst statusColor: Record<string, string> = {\n  init: \"black\",\n  success: \"green\",\n  almost: \"orange\",\n  never: \"grey\",\n};\n\ninterface CharColor {\n  ch: string;\n  color: string;\n}\n\ninterface Props {\n  pair: CharColor;\n}\n\nconst areEqual = (prevProps: Props, nextProps: Props): boolean => {\n  return prevProps.pair.ch === nextProps.pair.ch && prevProps.pair.color === nextProps.pair.color\n}\n\nconst Node = ({ pair }: Props) => {\n  return <span style={{ color: statusColor[pair.color] }}>{pair.ch}</span>;\n}\n\nexport default React.memo(Node, areEqual)","import React from \"react\";\nimport Node from \"./Node\";\n\ninterface CharColor {\n  ch: string;\n  color: string;\n}\n\ninterface Props {\n  guesses: CharColor[][];\n}\n\nconst Guesses = ({ guesses }: Props) => {\n  console.log('render guesses')\n  return(\n    <>\n      {guesses.map((guess, index) => (\n        <div key={index}>\n          {`guess #${index + 1}: `}\n          {guess.map((pair, index) => (\n            <Node key={`${pair.ch}${index}`} pair={pair} />\n          ))}\n        </div>\n      ))}\n    </>\n  )\n}\n\nexport default React.memo(Guesses)","import React from \"react\";\nimport Node from \"./Node\";\n\nconst rows = [\n  [\"q\", \"w\", \"e\", \"r\", \"t\", \"y\", \"u\", \"i\", \"o\", \"p\"],\n  [\"a\", \"s\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"],\n  [\"z\", \"x\", \"c\", \"v\", \"b\", \"n\", \"m\"],\n];\n\ninterface Alphabet {\n  [key: string]: string;\n}\n\ninterface Props {\n  alphabet: Alphabet;\n}\n\nconst Keyboard = ({ alphabet }: Props) => {\n  console.log(\"render keyboard\");\n  return (\n    <>\n      {rows.map((characters, index) => (\n        <div key={index}>\n          {characters.map((ch) => (\n            <Node\n              key={ch}\n              pair={{ ch: ch.toUpperCase(), color: alphabet[ch] }}\n            />\n          ))}\n        </div>\n      ))}\n    </>\n  );\n};\n\nexport default React.memo(Keyboard);\n","import React, { useState } from 'react'\n\ninterface Props {\n  handleSubmit(e: React.FormEvent, input: string): void \n}\n\nexport default React.memo(({ handleSubmit }: Props) => {\n  const [input, setInput] = useState<string>('')\n  return (\n    <form onSubmit={(e) => {handleSubmit(e, input)}}>\n      <input onChange={(e) => setInput(e.target.value)} value={input}/>\n      <button> guess </button>\n    </form>\n  )\n})","import React, { useState } from \"react\";\nimport { useGame } from \"./hooks/useGame\";\nimport Guesses from \"./components/Guesses\";\nimport Keyboard from \"./components/Keyboard\";\nimport InputWord from \"./components/InputWord\";\n\nconst App = () => {\n  console.log(\"render app\");\n  const { row, wordle, history, alphabet, status, newGame, submitGuess } =\n    useGame();\n\n  const handleSubmit = (e: React.FormEvent, input: string): void => {\n    e.preventDefault();\n    submitGuess(input);\n  };\n\n  return (\n    <div>\n      <div><strong> WIP ðŸ˜‚ </strong></div>\n      {`status: ${status}`}\n      <br />\n      {`guesses: ${row}`}\n      <br />\n      {`wordle: ${wordle}`}\n      <br />\n      <button onClick={newGame}> restart </button>\n      <br />\n      <InputWord handleSubmit={handleSubmit} />\n      <br />\n      <Guesses guesses={history.data} />\n      <br />\n      <Keyboard alphabet={alphabet.alphabet} />\n    </div>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}