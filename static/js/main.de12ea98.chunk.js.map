{"version":3,"sources":["App.tsx","hooks/useArray.tsx","hooks/useAlphabet.tsx","hooks/useLog.tsx","hooks/useGame.tsx","components/Node.tsx","components/Guesses.tsx","components/Keyboard.tsx","reportWebVitals.ts","index.tsx"],"names":["useArray","initial","useState","data","setData","push","element","remove","index","filter","_","i","update","length","previousData","slice","isEmpty","reset","initializeAlphabet","alphabet","start","charCodeAt","String","fromCharCode","useAlphabet","setAlphabet","ch","status","prevState","updateNever","undefined","updateAlmost","updateSuccess","useLog","name","useEffect","console","log","initHistory","history","j","color","randomInt","end","Math","floor","random","useGame","row","setRow","col","setCol","wordle","setWordle","setStatus","answers","useRef","words","Set","parseTextFile","filename","fetch","process","then","res","text","split","fetchWords","a","answersArr","wordsArr","current","concat","getCharColors","guess","wordColors","wordleSet","has","newGame","submitGuess","curWord","map","x","join","handleBackspace","newRow","handleChar","statusColor","init","success","almost","never","areEqual","prevProps","nextProps","pair","Node","style","React","memo","Guesses","guesses","rows","Keyboard","characters","toUpperCase","KEYS","add","App","handleKeyPress","e","code","key","toLowerCase","window","addEventListener","removeEventListener","onClick","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","error","debug","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.de12ea98.chunk.js","sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport useGame from \"./hooks/useGame\";\nimport Guesses from \"./components/Guesses\";\nimport Keyboard from \"./components/Keyboard\";\n\n// set of letters from 'a' to 'z'\nconst KEYS = new Set();\nfor (let i = 0; i < 26; i++) {\n  KEYS.add(String.fromCharCode(\"a\".charCodeAt(0) + i));\n}\n\nconst App = () => {\n  const {\n    row,\n    wordle,\n    history,\n    alphabet,\n    status,\n    newGame,\n    submitGuess,\n    handleBackspace,\n    handleChar,\n  } = useGame();\n\n  const handleKeyPress = (e: KeyboardEvent): void => {\n    if (e.code === \"Enter\") submitGuess();\n    else if (e.code === \"Backspace\") handleBackspace();\n    else if (KEYS.has(e.key.toLowerCase())) handleChar(e.key.toLowerCase());\n    else if (e.code === \"Space\") newGame();\n  };\n\n  useEffect(() => {\n    // Add event listeners on new render\n    window.addEventListener(\"keydown\", handleKeyPress);\n    // Remove event listeners on cleanup\n    return () => {\n      window.removeEventListener(\"keydown\", handleKeyPress);\n    };\n  }, [handleKeyPress]);\n\n  return (\n    <div>\n      <div>\n        <strong> WIP ðŸ˜‚ </strong>\n      </div>\n      {`status: ${status}`}\n      <br />\n      {`guesses: ${row}`}\n      <br />\n      {`wordle: ${wordle}`}\n      <br />\n      <button onClick={newGame}> restart </button>\n      <br />\n      <br />\n      <Guesses guesses={history.data} row={row} />\n      <br />\n      <Keyboard alphabet={alphabet.alphabet} />\n    </div>\n  );\n};\n\nexport default App;\n","import { useState } from \"react\";\n\n// Purpose of this hook is to mimic normal arrays, this allows us to 'mutate' our state which we otherwise wouldn't be able to in React\nconst useArray = <T extends any>(initial: T[] = []) => {\n  const [data, setData] = useState(initial);\n\n  // Can push to the data like normally when not using React\n  const push = (element: T): void => {\n    setData([...data, element]);\n  };\n\n  // Can remove from index of the data like normally when not using React\n  const remove = (index: number): void => {\n    setData(data.filter((_, i) => i !== index));\n  };\n\n  // Update element at index with new element\n  const update = (index: number, element: T): void => {\n    if (index < 0 || index >= data.length) return;\n    setData((previousData) => [\n      ...previousData.slice(0, index),\n      element,\n      ...previousData.slice(index + 1, previousData.length),\n    ]);\n  };\n\n  const isEmpty = (): boolean => data.length === 0;\n\n  const reset = (): void => setData([]);\n\n  return {\n    data,\n    setData,\n    useArray,\n    push,\n    remove,\n    update,\n    reset,\n    isEmpty,\n  } as const;\n};\n\nexport default useArray;\n","import { useState } from \"react\";\n\ninterface Alphabet {\n  [key: string]: string;\n}\n\nconst initializeAlphabet = (): Alphabet => {\n  let alphabet: Alphabet = {};\n  const start = \"a\".charCodeAt(0);\n  for (let i = start; i < start + 26; i++) {\n    alphabet[String.fromCharCode(i)] = \"init\";\n  }\n  return alphabet;\n};\n\nconst useAlphabet = () => {\n  const [alphabet, setAlphabet] = useState<Alphabet>(initializeAlphabet());\n\n  // Helper function to use 'setAlphabet' to prevent DRY\n  const update = (ch: string, status: string): void => {\n    if (alphabet[ch] === status) return;\n    setAlphabet((prevState: Alphabet) => ({ ...prevState, [ch]: status }));\n  };\n\n  // Updates a character to 'never'\n  const updateNever = (ch: string): void => {\n    if (\n      alphabet?.[ch] === undefined ||\n      alphabet?.[ch] === \"never\" ||\n      alphabet?.[ch] === \"almost\" ||\n      alphabet?.[ch] === \"success\"\n    )\n      return;\n    update(ch, \"never\");\n  };\n\n  // Updates a character to 'almost'\n  const updateAlmost = (ch: string): void => {\n    if (\n      alphabet?.[ch] === undefined ||\n      alphabet?.[ch] === \"almost\" ||\n      alphabet?.[ch] === \"success\"\n    )\n      return;\n    update(ch, \"almost\");\n  };\n\n  // Updates a character to 'success'\n  const updateSuccess = (ch: string): void => {\n    if (alphabet?.[ch] === undefined || alphabet?.[ch] === \"success\") return;\n    update(ch, \"success\");\n  };\n\n  // Reset alphabet to default\n  const reset = (): void => {\n    setAlphabet(initializeAlphabet());\n  };\n\n  return { alphabet, updateNever, updateAlmost, updateSuccess, reset } as const;\n};\n\nexport default useAlphabet;\n","import { useEffect } from \"react\";\n\nconst useLog = <T extends any>(name: string, data: T) => {\n  useEffect(() => {\n    console.log(name, data);\n  }, [name, data]);\n};\n\nexport default useLog;\n","import { useState, useEffect, useRef } from \"react\";\nimport useArray from \"./useArray\";\nimport useAlphabet from \"./useAlphabet\";\nimport useLog from \"./useLog\";\n\nconst MAX_GUESSES = 6;\nconst WORDLE_LEN = 5;\n\n// Returns a 2d array of our initial history array for our game\nconst initHistory = (): CharColor[][] => {\n  let history: CharColor[][] = [];\n  for (let i = 0; i < MAX_GUESSES; i++) {\n    history.push([]);\n    for (let j = 0; j < WORDLE_LEN; j++) {\n      history[i].push({ ch: \"_\", color: \"init\" });\n    }\n  }\n  return history;\n};\n\n// Returns random integer from [a, b]\nconst randomInt = (start: number, end: number): number => {\n  return start + Math.floor(Math.random() * (end - start + 1));\n};\n\ninterface CharColor {\n  ch: string;\n  color: string;\n}\n\nconst useGame = () => {\n  const [row, setRow] = useState<number>(0);\n  const [col, setCol] = useState<number>(0);\n  const [wordle, setWordle] = useState<string>(\"\");\n  const alphabet = useAlphabet();\n  const history = useArray<CharColor[]>(initHistory());\n  const [status, setStatus] = useState<string>(\"ongoing\");\n  const answers = useRef<string[]>([]);\n  const words = useRef<Set<string>>(new Set());\n\n  useLog(\"Log: history: \", history.data);\n  useLog(\"Log: alphabet: \", alphabet.alphabet);\n\n  // Function to read my text file from the 'public' folder on load\n  useEffect(() => {\n    const parseTextFile = (filename: string): Promise<string[]> => {\n      return fetch(`${process.env.PUBLIC_URL}/${filename}`)\n        .then((res) => res.text())\n        .then((text) => {\n          return text.split(/\\r?\\n/); // Split by /r/n on windows or /n on Unix using regex\n        });\n    };\n\n    // Parse 2 textfiles for answers + all words\n    const fetchWords = async (): Promise<void> => {\n      const answersArr = await parseTextFile(\"answers.txt\");\n      const wordsArr = await parseTextFile(\"words.txt\");\n      answers.current = answersArr;\n      words.current = new Set(wordsArr.concat(answersArr)); // All possible words include answers + normal words\n    };\n\n    // Pick a random wordle after fetching our answers + all words\n    fetchWords().then(() => {\n      const index = randomInt(0, answers.current.length);\n      setWordle(answers.current[index]);\n    });\n  }, []);\n\n  // Runs when the user presses space\n  const newGame = (): void => {\n    console.log(\"Log: started new game\");\n    const index = randomInt(0, answers.current.length); // Get a random index\n    setWordle(answers.current[index]); // Pick a random wordle\n    setCol(0); // Reset col\n    setRow(0); // Reset row\n    history.setData(initHistory()); // Reset history\n    alphabet.reset(); // Reset alphabet\n    setStatus(\"ongoing\"); // Reset status\n  };\n\n  // Runs when the user presses enter\n  const submitGuess = (): void => {\n    if (status !== \"ongoing\") return;\n    const curWord = history.data[row].map((x) => x.ch).join(\"\");\n    if (words.current.has(curWord)) {\n      history.update(row, getCharColors(curWord)); // Update row { guesses } of our history with new guess\n      setRow(row + 1); // Increment guess count\n      setCol(0); // New row, reset col back to 0\n      if (curWord === wordle)\n        // Check if game is over\n        setStatus(\"win\");\n      else if (row + 1 === MAX_GUESSES) setStatus(\"lose\");\n    }\n  };\n\n  // Runs when the user presses backspace\n  const handleBackspace = (): void => {\n    if (status !== \"ongoing\" || col === 0) return;\n    const newRow = history.data[row].slice();\n    newRow[col - 1] = { ch: \"_\", color: \"init\" };\n    history.update(row, newRow);\n    setCol(col - 1);\n  };\n\n  // Runs when the user presses an alphabetical character\n  const handleChar = (ch: string): void => {\n    if (status !== \"ongoing\" || col >= WORDLE_LEN) return;\n    const newRow = history.data[row].slice();\n    newRow[col] = { ch: ch, color: \"init\" };\n    history.update(row, newRow);\n    setCol(col + 1);\n  };\n\n  // Will update the alphabet with green/yellow/black colors and return the CharColor[] for this guesss\n  const getCharColors = (guess: string): CharColor[] => {\n    let wordColors: CharColor[] = [];\n    let wordleSet = new Set(wordle);\n\n    // Iterate through each character of the guess word\n    for (let i = 0; i < guess.length; i++) {\n      const ch: string = guess[i];\n      if (ch === wordle[i]) {\n        // Character at index i of guess is same as character of wordle\n        wordColors.push({ ch: ch, color: \"success\" });\n        alphabet.updateSuccess(ch);\n      } else if (wordleSet.has(ch)) {\n        // Otherwise, check if guess char is a char in the wordle\n        wordColors.push({ ch: ch, color: \"almost\" });\n        alphabet.updateAlmost(ch);\n      } else {\n        // Otherwise, mark the character as 'never' possible\n        wordColors.push({ ch: ch, color: \"never\" });\n        alphabet.updateNever(ch);\n      }\n    }\n    return wordColors;\n  };\n\n  return {\n    row,\n    wordle,\n    history,\n    alphabet,\n    status,\n    newGame,\n    submitGuess,\n    handleBackspace,\n    handleChar,\n  } as const;\n};\n\nexport default useGame;\n","import React from \"react\";\n\nconst statusColor: Record<string, string> = {\n  init: \"black\",\n  success: \"green\",\n  almost: \"orange\",\n  never: \"grey\",\n};\n\ninterface CharColor {\n  ch: string;\n  color: string;\n}\n\ninterface Props {\n  pair: CharColor;\n}\n\nconst areEqual = (prevProps: Props, nextProps: Props): boolean => {\n  return (\n    prevProps.pair.ch === nextProps.pair.ch &&\n    prevProps.pair.color === nextProps.pair.color\n  );\n};\n\nconst Node = ({ pair }: Props) => {\n  return <span style={{ color: statusColor[pair.color] }}>{pair.ch}</span>;\n};\n\nexport default React.memo(Node, areEqual);\n","import React from \"react\";\nimport Node from \"./Node\";\n\ninterface CharColor {\n  ch: string;\n  color: string;\n}\n\ninterface Props {\n  guesses: CharColor[][];\n  row: number;\n}\n\nconst Guesses = ({ guesses, row }: Props) => {\n  console.log(\"Log: render guesses\");\n  return (\n    <>\n      {guesses.map((guess, index) => (\n        <div key={index}>\n          {`guess #${index + 1}: `}\n          {guess.map((pair, index) => (\n            <Node key={`${pair.ch}${index}`} pair={pair} />\n          ))}\n          {index === row && <span> &lt;&lt; </span>}\n        </div>\n      ))}\n    </>\n  );\n};\n\nexport default React.memo(Guesses);\n","import React from \"react\";\nimport Node from \"./Node\";\n\nconst rows = [\n  [\"q\", \"w\", \"e\", \"r\", \"t\", \"y\", \"u\", \"i\", \"o\", \"p\"],\n  [\"a\", \"s\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"],\n  [\"z\", \"x\", \"c\", \"v\", \"b\", \"n\", \"m\"],\n];\n\ninterface Alphabet {\n  [key: string]: string;\n}\n\ninterface Props {\n  alphabet: Alphabet;\n}\n\nconst Keyboard = ({ alphabet }: Props) => {\n  console.log(\"Log: render keyboard\");\n  return (\n    <>\n      {rows.map((characters, index) => (\n        <div key={index}>\n          {characters.map((ch) => (\n            <Node\n              key={ch}\n              pair={{ ch: ch.toUpperCase(), color: alphabet[ch] }}\n            />\n          ))}\n        </div>\n      ))}\n    </>\n  );\n};\n\nexport default React.memo(Keyboard);\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\n// replace console.* for disable log on production\nif (process.env.NODE_ENV === \"production\") {\n  console.log(\"Log: no logs in production\");\n  console.log = () => {};\n  console.error = () => {};\n  console.debug = () => {};\n}\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}